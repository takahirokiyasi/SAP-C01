# EC2
## インスタンスタイプ
ネットワーク帯域はインスタンスタイプによって決まる
インスタンスタイプがIPv6に対応していない場合がある（M3など）

### 汎用
M4 M5
T3　バースト可能（CPUクレジットを使ってバースト）
A1　Armアーキテクチャ
### メモリ最適化
R4 R5 X1e
大量のメモリ容量が必要なDBサーバー等に利用
### コンピューティング最適化
C4 C5
APサーバーや画像処理に使用
### ストレージ最適化
D2 H1 I3
高速なIPOSや、大容量ストレージ容量が必要なDBサーバー、Data Warehouse、ビッグデータ処理に利用
### グラフィカルインスタンス
G3 G2
NVIDIA Tesla M60 GPUにアクセス可能

### 追加機能
C5nなどインスタンス世代の番号の後にオプション表記があるものがある
- d：標準インスタンスに対して、内臓ストレージ(インスタンスストア)を内蔵
- n：標準インスタンスに対して、ネットワークを強化
- a：AMDのCPUを搭載

## EBS最適化インスタンス
c3 m3 r3 t2などの旧世代インスタンスをのぞいてデフォルトでオン
ネットワークとは別の帯域を確保しIO性能の安定化を図っている

## Nitro System
EC2の新しいHyperviser
ネットワーク・ストレージ・暗号化の処理を専用のチップで処理させて、処理をオフロードすることによってホストコンピュターの性能を最大限活用できるようにしている

## EC2 Bare Metal
OSが直接下層のハードウェアにアクセス可能
ユーザー独自のハイパーバイザーを導入・管理する場合

## Key Pair
EC2インスタンス上のOSに対する安全な認証を提供する機能
ユーザーが秘密鍵を管理保管する（PEMキー .pem）
AWS側で公開鍵を保持しEC2の起動時に公開鍵をコピーする(Authorizedキー)

`AMIの作成時、公開鍵を除外しない限り、AMIに公開鍵(Authorizedキー)が内包された状態になる。`
同じキーペアを維持する場合は`PEMキーはユーザーの責任で`移行する必要がある

### プライベートキー（PEMキー）を紛失した場合
インスタンスを停止し、そのルートボリュームをデタッチし、データボリュームとして別のインスタンスにアタッチし、新しいパブリックキーで authorized_keys ファイルを変更して、ボリュームを元のインスタンスに戻し、インスタンスを再起動する必要があります。
1. 新しいキーペアを作成する
1. 元のインスタンスを停止する
1. 一時インスタンスを起動する
1. 元のインスタンスからルートボリュームをデタッチし、一時インスタンスにアタッチする
1. 一時インスタンスにマウントされた元のボリュームのauthorized_keys に、新しいパブリックキーを追加する
1. 一時インスタンスから元のボリュームをデタッチ、元のインスタンスに再アタッチ
1. 新しいキーペアを用いて元のインスタンスに接続

## IP
### Private IP
必ず割り当てられる
Stop Startしても同じIPが割り振られる
### Public IP
ランダムに割り当てられる
Stop Startすると別のIPが割り当てられる
割り当ての有無を変更することが可能
### Elastic IP(EIP)
別インスタンスへ再マップ可能な静的Public IP
Stop　StartしてもIPアドレスが維持される
利用していない場合に料金発生

## AMI　（OS イメージ）
cli APIで　describe-imagesを利用でAMIを探す
AWS MarketPlaceで探す
### HVM AMI
HVM AMI は、完全に仮想化された一連のハードウェアを備えており、イメージのルートブロックデバイスのマスターブートレコードを実行することによって起動します。この仮想化タイプでは、ベアメタルハードウェア上でオペレーティングシステムが動作するのと同様に、修正を行わなくても仮想マシン上でオペレーティングシステムを直接実行することができます。PV AMIとは異なり、HVM AMIは、ホストシステム上の基盤となるハードウェアへの高速なアクセスを可能にするハードウェア拡張を利用できます。
高いネットワークパフォーマンスを実現

## Auto Scalingグループ
プライベートサブネットにある場合はPrivate Linkを使用することでVPCにAmazon EC2 Auto Scaling API の間に接続を確立できる。
### CLIコマンド
terminate-instance-in-auto-scaling-group CLIコマンドにより、指定されたインスタンスを終了し、必要に応じて必要なグループサイズを調整します。この呼び出しは、インスタンスがただちに終了しないように、終了要求を行います。

このコマンドを実行する際は--should-decrement-desired-capacity または --no-should-decrement-desired-capacityを利用して、インスタンス数の調整オプションの設定が必要

## Auto Recovery
ネットワークやハードウェアの不具合によって発生したシステムステータスチェックの失敗をトリガーにしてEC2インスタンスを再起動することができる。
backed-EBSのみサポート

## User data
起動時にスクリプト実行を行う機能

## Launch template
設定をテンプレート化して一発で起動できる機能

## インスタンスメタデータ
インスタンスのメタデータの中には、資格情報が入っており、ロールに添付されたポリシーで指定された権限が付与されている。

## プレイスメントグループ
プレイスメントグループの設定は先にプレイスメントグループを構成した上で、その中でインスタンスタイプとインスタンス数を決定することが必要
インスタンスタイプは同じものでないとだめ
`単一のアベイラビリティーゾーン`内のインスタンスを論理的にグループ化したもの

### クラスタープレイスメントグループ
単一のアベイラビリティーゾーン内のインスタンスを論理的にグループ化したもの。
クラスタープレイスメントグループは、同じリージョン内の複数のピア VPC にまたがることができます。同じクラスタープレイスメントグループ内のインスタンスは、TCP/IP トラフィックのフローあたりのスループット上限が高くなり、ネットワークの二分帯域幅の広い同じセグメントに配置されます。
個々のインスタンス間の通信が高速になる

### スプレッドプレイスメントグループ
EC2インスタンスを別々のハードウェアに分散して配置することができるもので耐障害性を高めるもの
HAのクラスタを展開している際に有効

### パーティションプレイスメントグループ
EC2のハードウェア障害の影響を最小化するためのもので、各インスタンスをパーティションに分けて
それぞれのパーティションはハードウェアを共有しないようにするもの

### プレイスメントグループの追加
インスタンスタイプを統一し、追加に伴うインスタンス総数を再設定して追加した上で、プレイスメントグループを再起動することが必要。
既存のプレイスメントグループに新規EC2インスタンスを追加する際は、インスタンスグループ全体を一旦停止してから、新規EC2インスタンスをグループに追加して、プレイスメントグループにあるEC2インスタンスを再起動することで解決することができる
追加するインスタンスを停止させて、プレイスメントグループに追加するだけ説もある。全体を停止させる必要があるのか謎（ちゃんと載ってない）

## CPU最適化オプション
インスタンスの起動時にCPUコア数、ハイパースレッディングを無効化する
CPUのキャッシュを占有する方が早い演算などはこれが有用（浮動小数点の演算など）

起動後の変更はできない
ベアメタルインスタンスでは利用できない

## EC2にGPUをアタッチできる機能
### Elastic Graphics
T2インスタンスなど安価なインスタンスにGPUを追加することでG2　G3より安価にGPUを利用可能
３Dグラフィックス処理が可能
### Elastic Interface
Deep Learningの推論処理を高速化できるサービス
Tensorflow Apache MXNetをサポート

## EC2のライフサイクル
### Running
実行中
課金される
### Stopped
停止中
課金されない
Instance Store-Backed AMIはストップ状態にできない
### hibernate(休止)
メモリ状態をディスクに書き出した上でインスタンスの停止可能になり、インスタンスを再開したら途中からスタート可能。
休止したインスタンスが stopped 状態にある場合、インスタンスの使用量に対して料金は発生しない
### Terminated
削除ずみ

## EC2のハイバネーション機能(EC2インスタンスの休止)
メモリ状態をディスクに書き出した上でインスタンスの停止可能になり、インスタンスを再開することで処理の途中からスタートできるし、起動時間も普通に停止から起動にするよりは早い
EC2のインスタンスメモリをEBSルートボリュームに保存している。
- EBSが必須で、EBSの暗号化が前提
- 起動時に休止を有効化することはできない
- インスタンスタイプに制限がある（C3, C4, C5, M3, M4, M5, R3, R4, R5）
- Auto Scaling グループのインスタンスは休止できない（異常と判断し別のインスタンスを起動するから）
- Amazon ECS が使用中のインスタンスは休止できない

## EC2フリート
EC2フリートはスポットインスタンスとオンデマンドインスタンスを組み合わせて定義ができるもの
API　CLIのみ対応
## スポットフリート
スポットフリートはスポットインスタンスしか定義ができないフリートの集まり（オプションでオンデマンドインスタンスもできる）

## EC2の古いwindowsアップデート方式
### インプレースアップグレード
オペレーティングシステムファイルをアップグレードし、個人の設定およびファイルは維持される
### 並行アップグレード
設定、構成、データを取り込み、この情報を新しい Amazon EC2 インスタンス上のより新しいバージョンのオペレーティングシステムに移行する方法

## （Linux）拡張ネットワーキング
シングルルート I/O 仮想化 (SR-IOV) を使用する
（通常はOSから仮想のインターフェイスからネットワークにアクセスしてるが、ネットワーク直接インスタンスからネットワークインターフェイスにアクセスできるようになり早くなってる）
高い帯域幅、1 秒あたりのパケット (PPS) の高いパフォーマンス、常に低いインスタンス間レイテンシーを実現
追加料金なし
### Elastic Network Adapter (ENA) 
サポート対象のインスタンスタイプに対して`最大100Gbps`のネットワーク速度をサポートすることができる
現行のインスタンスではT2以外は可能

ENAのドライバがないAMIではOSのブートに失敗する

### Intel 82599 Virtual Function (VF) インターフェイス
インスタンスタイプ C3、C4、D2、I2、M4 (m4.16xlarge を除く)、R3にて使用可能
最大10Gbps

## EFA(Elastic Fabric Adapter)
さらに通信を高速にするためのやつ
`ハイパフォーマンスコンピューティング (HPC)` と機械学習アプリケーションを高速化するために Amazon EC2 インスタンスにアタッチできるネットワークデバイスです。EFA では、AWS クラウドが提供するスケーラビリティ、柔軟性、伸縮性により、オンプレミスの HPC クラスターのアプリケーションパフォーマンスを実現できる。
MPI（Message Passing Interface）を利用したアプリケーションをより高速に

## 物理ホスト占有インスタンス　
普通のEC2はマルチホストが前提だけどこのオプションを使うことでインスタンスを占有できる
共通機能
- お客様専用の物理サーバーにインスタンスを起動可能
### ハードウェア占有インスタンス(Dedicated Instance)
インスタンスはシングルテナントのハードウェア
どのハードウェアで起動するかは固定できない
インスタンス単位での課金

コンプライアンス要件などで他人と異なるサーバで起動する必要がある場合に利用

### Amazon EC2 Dedicated Host
物理ホストへのインスタンス配置が制御・確認可能
インスタンスを`同じ物理サーバー`に徐々にデプロイし続けることができる
ハードウェアのCPUソケット、コア、ホストIDレベルで固定することができる。
インスタンスを停止し、再起動しても同じハードウェアを利用できる。
ソフトライセンスの持ち込み（BYOL）可能
物理ホスト単位での課金
特定のAMIを利用できない（RHEL/SUSE Linux/Windows AMI）

ソフトウェアライセンスがハードウェアに依存する場合やBYOL(Bring Your Own License)やハードウェアを固定する場面で利用。

# インスタンスストア
一時記憶域として利用
物理的にEC2と繋がってる
SSD HDDが選べる
停止・終了すると消える

## AMI作成
インスタンスストアにバックアップされたLinux AMIを作成するには、既存のインスタンスストアにバックアップされたLinux AMIから起動したインスタンスを利用します。ニーズに合わせてインスタンスをカスタマイズしたら、ボリュームをバンドルし、これらのカスタマイズで新しいインスタンスを起動するために使用できる新しいAMIを登録します。インスタンスストアボリュームのAMI作成プロセスは、Amazon EBS-backed AMIとは異なり、コンソール画面から実行できません。 ec2-bundle-volやec2-upload-bundleなどのAMIツールが必要です。

# EBS
1つのインスタンスが複数のEBSに接続することは可能だが
2つのインスタンスから同じEBSは接続できない
S3にスナップショットを取得し任意のAZに復元できる

冗長化のためのRAID構成は不要
セキュリティグループの対象外
EC2の全ポートを閉じていてもEBS使用可能

## 種類
### SSD
#### 汎用SSD　gp2
デフォルトのボリュームタイプ

開発・テスト環境
仮想デスクトップ
小規模データベース
負荷が読めないシステム
最大　16000IOPS

バースト機能があり容量が少なくても3000IOPSまで出せるが、クレジットの上限がある。
メトリクスBurstBlanceでクレジット残量が見れる。それが０になっている場合は容量を増加させるかio1への変更を検討必要
容量によって時間経過によってたまるクレジットが変わる

#### プロビジョンドIOPS io1
Nitroベースインスタンスに対しては最大64000IOPS
他は最大32000IOPS

容量とIOPSの最大割合は50:1 100GiBのボリュームは最大5000IOPS
最初から必要なIOPSを指定

RBDなどの利用
Elastic Search

### HDD
以下両方バーストが利用可能
SDDの汎用の方がIPOS性能は良い
#### スループット最適化HDD st1
ビッグデータ、分析
Hadoop
データウェアハウス
EMR

#### コールドHDD sc1
ログデータ
アーカイブ
低頻度アクセスデータ

## EBSのパフォーマンスでボトルネックになるもの
### EC2インスタンスのスループットの上限
EC2側の帯域が細い
- 最新ではないインスタンスタイプの場合はEBS最適化（EBS-Optimized）を有効にする
- EC2インスタンスタイプによって決まるEBSスループットの上限値に達していないか確認する　CloudWatchのVolume　Read・Write Bytesの合計値　OSでEBSボリュームへの総流量を確認　iostatやperformなど
上限に達している場合はインスタンスタイプを大きくすることで改善する
### EBSのIOPSがボトルネック
EBSボリューム側の実績IOPSを確認する
CloudWatchのVolumeRead Write Opsの合計値
上限に達していればボリュームの変更をする
HDD→gp2 gp2→io1
### EBSのスループット上限
CloudWatchのVolumeRead Write Bytesの合計値
gp2→io1 (gp2→st1　シーケンシャルIOの時だけ)
スループットは1秒間の最大データ転送量
IOPSはストレージが1秒あたりに処理できるI/O（書き込み・読み込み）アクセスの数

[スループットとIOPSの違い](https://dev-labo.com/aws/difference-iops-throughput/)
[シーケンシャルとランダムアクセス](https://kb-jp.sandisk.com/app/answers/detail/a_id/8980/~/%E3%82%B7%E3%83%BC%E3%82%B1%E3%83%B3%E3%82%B7%E3%83%A3%E3%83%AB%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%A8%E3%83%A9%E3%83%B3%E3%83%80%E3%83%A0%E3%82%A2%E3%82%AF%E3%82%BB%E3%82%B9%E3%81%AE%E6%93%8D%E4%BD%9C%E3%81%AE%E9%81%95%E3%81%84)

## NVMe SSD
Nitro ベースインスタンスではNVMeブロックデバイスとしてEBSボリュームを認識
NVMeドライバを利用しEBSを検出

## Elastic Volume
EC2にアタッチ中に`サイズやIPOSを変更可能`
gp2からio1など`EBSのボリュームタイプ`も変更可能

一度変更すると６時間変更不可
変更自体は無料

## 暗号化
EBSデータは既存の暗号化機能を有効化することで、データを暗号化することができます
特に暗号化を意識することなく、利用可能でパフォーマンスへの影響は小さい

ボリュームの暗号化ごとにData　Keyを生成し、データと共にボリューム上に保存される。
Data Keyの生成に必要なカスタマーキーはAWS Key Management Service (AWS KMS) のカスタマーマスターキー (CMK) とカスタマー管理のCMKを利用可能

デフォルトで暗号化する場合はリージョンごとの設定でデフォルト化可能（個々のEBSの単位で無効にするとかは無理）

### EBS作成してしまった後に暗号化する方法
スナップショットを取得して、暗号化を有効にしてスナップショットをコピー
スナップショットからEBSボリュームを作成して、新しいボリュームを既存のEC2にアタッチ

### 暗号化の解除をしたい場合
暗号化を無効化はできないので
新規ボリュームを作成してOS側でデータのコピーを行う
rsyncコマンド

## EBS snapshot
データの整合性のために静止点をもうけることが必要（DBを一時的に止める機能を使うなど）

フルバックアップ　増分バックアップとか可能
ふるバックアップを削除しても増分バックアップ1にフルバックアップにコピーされてデータが保持される。

リージョン間コピー可能 Cloudwatch Eventsと連携可能

リストア　S3にあるスナップショットからEBSを作成し、古いものと置き換える

以下作成方法４つ
コンソール&CLI

### Amazon Data Lifecycle Manager(DLM)
※EBS固有の機能ではない
Amazon EBS ボリュームをバックアップするスナップショットの作成、保持、削除を自動化できます。
世代管理の自動化もできる

EBSスナップショットのライフサイクルポリシーによって定期的にスナップショットの取得や削除といった対応をスケジュール設定することが可能
ボリュームのタグごとにポリシーを設定可能
指定した開始時間から１時間以内で開始
インスタンスの状況の考慮はされないので夜間など一時停止できる環境で推奨
### AWS Backup
EBSだけでなく他のサービスも含めて一元的に管理したい場合これ
EFS RDS Dynamo Storage gateway

### System manager Cloud Watch Evnet
LinuxだけでなくWindowsのワークロードも含まれている場合


#### スナップショットのコピーは設定の影響を受けない
スナップショットをコピーする場合、新しいコピーはデータ保存期間設定の影響を受けない

## マルチアタッチ
ボリュームタイプはプロビジョンドIOPS(io1)である必要あり
EC2インスタンスはNitroベースのインスタンスである必要
EC2インスタンスはEBSボリュームと同一アベイラビリティゾーン
アプリケーション側で排他制御する必要あり。

# ECS
## EC2を使用する場合のAuto Scaling 
ECS Cluster Auto Scalingを有効にするには、Capacity Providerと呼ばれる新たな項目を設定する必要があります。
1つのCapacity Providerは1つのEC2 Auto Scalingグループに関連付けられます。
あるAuto ScalingグループにECS Capacity Providerを関連付けてから、ECSクラスターにCapacity Providerを追加すると、クラスターを自動スケールできるようになります。

# EKS
Kubernetes は、コンテナ化されたアプリケーションのデプロイ、スケーリング、および管理を自動化するためのオープンソースシステムです。Amazon EKSはユーザーに代わって他のAWSサービスを呼び出してサービスで使用するリソースを管理します

１つのVPC内に２つのAZにクラスターを構成することが必要

## RBAC(Role-based access control)
役割ベースのアクセス制御機能

https://aws.amazon.com/jp/premiumsupport/knowledge-center/eks-iam-permissions-namespaces/


# Elastic Beanstalk

## RDSはElastic Beanstalk環境に組み込まず、個別で立てた方が良い
RDSインスタンスはElastic Beanstalk環境の一部となると、パフォーマンスに最適ではないため、RDSを個別に作成して利用することが好ましい。データベースインスタンスのライフサイクルをアプリケーション環境のライフサイクルに結び付けるため、実稼働環境に理想的なものではない。

## 実行できるデプロイポリシー
### All at once
新しいバージョンをすべてのインスタンスに同時に展開します。 環境内のすべてのインスタンスは、展開が行われている間、短時間サービスが停止します。 これは、展開に必要な合計時間を最短にする方法です。

### Rolling(ローリング)
Elastic Beanstalk は環境の EC2 インスタンスを複数のバッチに分割し、アプリケーションの新しいバージョンを一度に 1 つのバッチにデプロイするため、環境内の残りのインスタンスは古いアプリケーションバージョンを実行した状態になります。つまりローリングデプロイ中は、アプリケーションの古いバージョンでリクエストを処理するインスタンスもあり、新しいバージョンでリクエストを処理するインスタンスも存在します。

### Rolling with additional batch
新しいバージョンをバッチで展開しますが、最初にインスタンスの新しいバッチを起動して、展開プロセス中に完全な容量を確保します。

### Immutable
変更不可能な更新を実行して、古いバージョンを起動しているインスタンスと並行しながら、別の Auto Scaling グループにあるアプリケーションの新しいバージョンを起動している新しいインスタンスのフルセットを起動します。Immutable デプロイは、部分的に完了したローリングデプロイにより発生する問題を防止できます。新しいインスタンスがヘルスチェックをパスしなかった場合、Elastic Beanstalkはそれを終了し、元のインスタンスをそのまま残します。

### ブルーグリーンデプロイ
デプロイオプションとしては提供されていないが、「現在の環境のクローンを作成」という機能を使い、新しい環境を作る。
環境URLのスワップという機能を使ってCANMEを交換することにより新しい環境にルーティングされる。

# Lambda
## LambdaとX-Ray
Lambdaの処理ステップのどこがボトルネックかを用意に判別できるようになる
## VPC Lambda
NATgatewayを使わないとインターネット接続できない。

## Lambda@Edge
※cloudfrontの機能
Lambda@Edgeとは、AWS Lambda の拡張機能で、CloudFront が配信するコンテンツをカスタマイズする関数を実行できるコンピューティングサービスで世界中のビューワーの最寄りのAWSのロケーションで実行することができる。
CloudFrontディストリビューションをLambda@Edge関数に関連付けると、CloudFront は、CloudFrontエッジロケーションでリクエストとレスポンスを傍受します。Lambda関数は、次のCloudFrontイベントの発生時に実行できる。

 - CloudFront がビューワーからリクエストを受信したとき (ビューワーリクエスト)
 - CloudFront がリクエストをオリジンに転送する前 (オリジンリクエスト)
 - CloudFront がオリジンからレスポンスを受信したとき (オリジンレスポンス)
 - CloudFront がビューワーにレスポンスを返す前 (ビューワーレスポンス)

# API gateway

## 統合
### Lambda 統合
#### Lambda プロキシ統合
特徴
- クライアントの API リクエストをLambda 関数に raw リクエストをそのまま渡せること
- プロキシ統合のLambda 関数は決められた形式で返却する必要があること（ステータスコードとかヘッダーを指定したり）
#### Lambda 非プロキシ統合（カスタム統合）
受信リクエストデータがどのように統合リクエストにマッピングされるか、統合レスポンスデータの結果がメソッドレスポンスにどのようにマッピングされるかを指定しないといけないため少しめんどくさい

### HTTP 統合
EC2とかにバックエンドサーバー立ててALBとか間に挟んで通信
こちらのプロキシ統合と非プロキシ統合があるがLambdaのやつと違いはほぼ同じ

#### VPC link
VPCリンクを使用すると、Application Load Balancerまたは Amazon ECS コンテナベースのアプリケーションなどの、HTTP API ルートを VPC 内のプライベートリソースに接続するプライベート統合を作成できる。

### AWSサービス統合
#### S3との統合
#### Kinesisとの統合

## APIの種類
### HTTP API
API Gatewayのコアな機能に特化して`低レイテンシー・低コスト`で利用したい場合に適した機能
認証は初めはJITオーソラーザーだけだったが、LambdaとIAMが使えるようになった。
REST APIからの移行が進んでいる

### REST API
WAFを使えたりuseage plansなどHTTP APIより多くの機能が使えたりする。

[HTTP APIとREST APIの違い](https://dev.classmethod.jp/articles/amazon-api-gateway-http-or-rest/)

#### エンドポイントタイプ
作成時にエンドポイントタイプを選択できる。

##### エッジ最適化APIエンドポイント
デフォルトのエンドポイントタイプ
地理的に分散されたクライアントに最適で、API リクエストは、最寄りの CloudFront POP (Point Of Presence) にルーティングされる。
S3の署名付きURLの代わりでAPIGateway＋Cognitoでやる

##### プライベートAPIエンドポイント
VPCからしかアクセスできないAPIエンドポイント

##### リージョンAPIエンドポイント
同じリージョンのクライアントを対象としたエンドポイント

#### リソースポリシー
API Gateway リソースポリシーを使用すると、APIを以下から安全に呼び出すことができる。
- 指定された AWS アカウントのユーザー
- 指定されたソース IP アドレス範囲または CIDR ブロック
- 指定された Virtual Private Cloud (VPC) または VPC エンドポイント (任意のアカウント)

許可されていないIPからアクセスしたりすると403が返ってくる

### WebSocket API
WebSocketのAPI

## 認証
### JITオーソライザー
HTTP　APIで使える認証
IDを取得するヘッダーと発行者のURLと
対象者という名前のクライアントIDを指定するだけでOK
Cognitoを使用する場合はヘッダーはAuthorization、CognitoのurlとClientIDを指定すればHTTP APIでもCognitoが使える

### IAMオーソライザー

### Lambdaオーソライザー
Lambda 関数を使用してAPIへのアクセスを制御するAPI Gateway の機能
二種類ある
1. トークンベースのLambdaオーソライザー(TOKENオーソライザー) は、JSON ウェブトークン (JWT) や OAuth トークンなどのbearer tokenで発信者 IDを受け取ります。

1. リクエストパラメータベースの Lambda オーソライザー (REQUESTオーソライザー) は、ヘッダー、クエリ文字列パラメータ、stageVariables、および $context 変数の組み合わせで、発信者 ID を受け取ります。
WebSocket API では、リクエストパラメータベースのオーソライザーのみがサポートされています。

https://docs.aws.amazon.com/ja_jp/apigateway/latest/developerguide/apigateway-use-lambda-authorizer.html#api-gateway-lambda-authorizer-flow

### CognitoのUserPoolを使ったオーソライズ

## usage plans(使用プラン)
それぞれのエンドポイントに対して回数制限やリクエストできるメソッド（POST）とかを制限できるようになった
顧客のAPIの予算の制約とかに応じてリクエスト回数絞ったりとかのユースケースに対応
REST APIの機能

### APIキー
使用プランの機能を使用するためにAPIキーを要求するエンドポイントを用意して
顧客に配布するAPIキーを生成し、リクエストのヘッダーにセットしてもらったり、LambdaオーソライザーでAPIキーをレスポンスに含めたりできる。

##　CORS機能
リクエストできるドメインを制限できる

## エラー
### INTEGRATION_FAILURE
Lambda関数とAPI Gatewayとの統合失敗を示す
### INTEGRATION_TIMEOUT
Lambdaファンクションが実行しない場合

## メトリクス
- 4XXError：指定された期間に取得されたクライアント側エラーの数。
- 5XXError：指定された期間に取得されたサーバー側エラーの数。
- CacheHitCount：指定された期間内に API キャッシュから配信されたリクエストの数。
- CacheMissCoun：API キャッシュが有効になっている特定の期間における、バックエンドから提供されたリクエストの数。
- Count：指定された期間内の API リクエストの合計数。
- IntegrationLatency：API Gateway がバックエンドにリクエストを中継してから、バックエンドからレスポンスを受け取るまでの時間。
- Latency：API Gateway がクライアントからリクエストを受け取ってから、クライアントにレスポンスを返すまでの時間。

## ステージ変数
API Gateway のデプロイステージでは、アルファ、ベータ、プロダクションなど、各 API 用の複数のリリースステージを管理できます。
ステージ変数を使用することで、異なるバックエンドのエンドポイントとやり取りするよう API デプロイステージを設定できます。
それによって、test.pintor.comエンドポイントとmain.pintor.testエンドポイントを介したテスト版リリースを使用して、本番リリースに接続するといった設定が可能

# SWF(Amazon Simple Workflow Service)
Amazon SWF は、開発者が並行したステップまたは連続したステップがあるバックグラウンドジョブを構築、実行、スケールするのに役立つ。Amazon SWF は、クラウド内の完全マネージド型の状態トラッカー、およびタスクコーディネーターとみなすことができる。

SWFでもSWFアクティビティの代わりにLambdaを実行することができる

例）動画の処理

# AWS Step Function
個々のLambdaをつなげるためのサービス

## モニタリング
人の作業によるアクティブティはCloudTrailで監視する。
システム状況のモニタリングはCloudWatchを使用する。

## SWF・Step Function使い分け
AWS Step Functions では、AWS の複数のサービスをサーバーレスのワークフローに整理できるため、すばやくアプリケーションをビルドおよび更新できます。これを利用することでSWFよりも視覚的に容易にワークフローを作成できるため、通常のワークフロー作成ではAWS Step Functionsの利用が推奨されている。
プロセスにおいて介入する外部信号が必要な場合、または結果を親に返す子プロセスを起動する場合は、AWS Step Functions では対応できないため、Amazon SWF使用することが求められている。

## AWS Step Functions Expressワークフロー
AWS Step Functions ワークフローの新しいワークフロータイプです。これにより、AWS のコンピューティング、データベース、メッセージングサービスを毎秒 100,000 件を超えるイベントレートでコスト効率よく調整できます。Express Workflow は、Amazon API Gateway を介した HTTP リクエスト、AWS Lambda リクエスト、AWS IoT ルールエンジンのアクション、および Amazon EventBridge の 100 件以上の AWS および SaaS イベントソースなどのイベントに応じて、自動的に開始されます。Express Workflows は、`IoT データ`の取り込み、`ストリーミングデータの処理と変換`、大量のマイクロサービスオーケストレーションなどの大量のイベント処理ワークロードに適しています。

## SWF マーカー
カスタム情報を記録する場合に使用する。マーカーを使用して、再帰的なワークフローでループの数を数えることができたりする。

# App Sync
AppSyncはAWSの管理系GraphQLサービスにて、ApolloやPrismaと比べてAWSからインフラやサーバーまで提供してくれるサービス
デバイス間でアプリケーションデータを同期するためのサービス
リアルタイム性が必要なサービスで使用すると良い
DynamoDB・Elastic Search・Lambdaをデータソースとして指定可能

## GraphOL Subscription
データの更新があるとアプリ側でSubscribe可能
ポーリングしておく必要がない

## GraphQL proxy
データのアクセスコントロール

# AWS Batch
データ分析タスクのスケジュールに使用されるbashスクリプトをAWS Batchに移行して実行することが可能です。 AWS Batchスケジューラはbashスクリプトによるジョブをいつ、どこで、どのように実行するかを評価します。
内部でECSを使ってる


# AWS CLI
## コマンド
### --max-items
AWS CLI 出力で一度に含める項目を少なくするには、--max-items オプションを使用します。前述したように、AWS CLI はサービスとのページ区切りを処理しますが、指定した時点での項目数のみを出力します。 
### --page-size
--page-size オプションを使用して、AWS CLI が AWS のサービスの 1 回の呼び出しで要求する項目数を少なくすることができます。
その場合でも、CLI は完全なリストを取得しますが、多数のサービス API コールをバックグラウンドで実行し、1 回の呼び出しで取得する項目数が少なくなります。このため、個々の呼び出しがタイムアウトにならずに成功する可能性が高くなります。
ページサイズを変更しても、出力には影響しません。出力を生成するために必要な API 呼び出しの数が変わるだけです。

